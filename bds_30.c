/*
 * Copyright © 2016 Lars Lindqvist <lars.lindqvist at yandex.ru>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3, as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

#include "bds_30.h"
#include "mac.h"

/*
 * MV - Message, ACAS
 * [1] 4.3.8.4.2.2
 * [1] 4.3.8.4.2.4
 * [3] Table A-2-48
 *
 * 3       4         5         6         7         8
 *  34567890123456789012345678901234567890123456789012345678
 *  VDS1    ARA           RAC  MTE                 
 *      VDS2                  RAT TID               
 *                              TTI
 *                                [CA   0 q   ][TIDR ][TIDB]
 *  01234567012345670123456701234567012345670123456701234567
 *  0       1       2       3       4       5       6
 *  4       5       6       7       8       9      10
 *                                2109876543210
 *
 */
struct ms_BDS_30_t *
mk_BDS_30(const uint8_t *m) {
	struct ms_BDS_30_t *ret;

	ret = calloc(1, sizeof(struct ms_BDS_30_t));

	ret->ara41 = m[1] & 0x80;
	ret->ara42 = m[1] & 0x40;
	ret->ara43 = m[1] & 0x20;
	ret->ara44 = m[1] & 0x10;
	ret->ara45 = m[1] & 0x08;
	ret->ara46 = m[1] & 0x04;
	ret->ara47 = m[1] & 0x02;

	ret->RAC.below = m[2] & 0x02;
	ret->RAC.above = m[2] & 0x01;
	ret->RAC.left  = m[3] & 0x80;
	ret->RAC.right = m[3] & 0x40;
	ret->RAC.raw = ((m[2] & 0x03) << 2)
	             |  (m[3] >> 6);

	ret->RAT   = m[3] & 0x20;
	ret->MTE   = m[3] & 0x10;

	ret->TTI   = (m[3] & 0x0F) >> 2;

	if (ret->TTI == 1) {
		ret->TID  = ((m[6] <<  0)
			  |  (m[5] <<  8)
			  |  (m[4] << 16)
			  |  (m[3] << 24)) & 0x03FFFFFF;
	} else {
		ret->TIDA.raw = ((m[3] & 0x03) << 11)
		                 |  (m[4] << 3)
		                 |  (m[5] >> 5); 
		ret->TIDA.alt_ft = decode_AC(ret->TIDA.raw, true);
		ret->TIDA.Q = ret->TIDA.raw & 0x10;
		ret->TIDA.M = ret->TIDA.raw & 0x40;

		ret->TIDR = ((m[5] & 0x1F) << 1)
		          |  (m[6] >> 6);

		ret->TIDB = m[6] & 0x3F;
	}

	return ret;
}

/*
 * TTI
 * [1] 4.3.8.4.2.2.1.5
 */
static void
pr_TTI(FILE *fp, uint8_t TTI) {
	fprintf(fp, "TTI=%d:Threat type indicator:%s\n", 
	       TTI,
	       TTI == 0 ? "No identity data in TID" :
	       TTI == 1 ? "TID contains Mode S transponder address" :
	       TTI == 2 ? "TID contains altitude, range and bearing data"
	                : "Not assigned");
}

/*
 * TIDR
 * [1] 4.3.8.4.2.2.1.6.2
 */
static void
pr_TIDR(FILE *fp, uint8_t tidr) {
	fprintf(fp, "TIDR=%d:Threat identity data range:", tidr);
	if (tidr == 0)
		fprintf(fp, "No range estimate available\n");
	else if (tidr == 1)
		fprintf(fp, "< %.2f NM\n", 0.05);
	else if (tidr == 127)
		fprintf(fp, "> %.2f NM\n", 12.55);
	else
		fprintf(fp, "%.2f ± %.2f NM\n", (tidr - 1) / 10.0, 0.05);
}

/*
 * TIDB
 * [1] 4.3.8.4.2.2.1.6.3
 */
static void
pr_TIDB(FILE *fp, uint8_t tidb) {
	fprintf(fp, "TIDB=%d:Threat identity data bearing:", tidb);
	if (tidb == 0)
		fprintf(fp, "No bearing estimate available\n");
	else if (tidb > 60)
		fprintf(fp, "Not assigned\n");
	else
		fprintf(fp, "%d° < bearing ≤ %d°\n", 6 * (tidb - 1), 6 * tidb);
}

/*
 * RAT - RA terminated indicator
 *
 */
static void
pr_RAT(FILE *fp, bool RAT) {
	if (RAT) {
		fprintf(fp, "RAT=%d:RA has been terminated.\n", RAT);
	} else {
		fprintf(fp, "RAT=%d:RA is currently generated by ACAS.\n", RAT);
	}
}

/*
 * RAC - Resolution advisory complement
 * [1] 4.3.8.4.2.2.1.2
 */
static void
pr_RAC(FILE *fp, struct ms_RAC_t RAC) {
	fprintf(fp, "Resolution advisory complement:%d\n", RAC.raw);
	fprintf(fp, "RAC:Do not pass below:%s\n", RAC.below ? "Active" : "Inactive");
	fprintf(fp, "RAC:Do not pass above:%s\n", RAC.above ? "Active" : "Inactive");
	fprintf(fp, "RAC:Do not turn left:%s\n",  RAC.left  ? "Active" : "Inactive");
	fprintf(fp, "RAC:Do not turn right:%s\n", RAC.right ? "Active" : "Inactive");
}

void
pr_ACAS_RA(FILE *fp, const struct ms_BDS_30_t *p, int v) {
	if (v == 1) {
		/* TODO */
	} else {
		/* MTE - Multiple threat encounter */
		if (p->MTE) {
			fprintf(fp, "RA:Multiple threats\n");
		} else {
			if (p->ara41) {
				fprintf(fp, "RA:One threat\n");
			} else {
				fprintf(fp, "RA:No threats\n");
			}
		}

		/*
		 * ARA - Active resolution advisory
		 * [1] 4.3.8.4.2.2.1.1
		 */
		if (p->ara41) {
			/* Regardless of MTE */
			fprintf(fp, "RA:%s\n", p->ara42 ? "Preventive" : "Corrective");
			fprintf(fp, "RA:%s sense generated\n", p->ara43 ? "Upward" : "Downward");
			fprintf(fp, "RA:Increased rate:%s\n", YESNO(p->ara44));
			fprintf(fp, "RA:Sense reversal:%s\n", YESNO(p->ara45));
			fprintf(fp, "RA:Altitude crossing:%s\n", YESNO(p->ara46));
			fprintf(fp, "RA:%s\n", p->ara47 ? "Positive" : "Vertical speed limit");
		}
		else if (p->MTE) {
			/* MTE ∧ ¬ARA41 */
			fprintf(fp, "RA:Upward correction required:%s\n",   YESNO(p->ara42));
			fprintf(fp, "RA:Positive climb required:%s\n",      YESNO(p->ara43));
			fprintf(fp, "RA:Downward correction required:%s\n", YESNO(p->ara44));
			fprintf(fp, "RA:Positive descend required:%s\n",    YESNO(p->ara45));
			fprintf(fp, "RA:Crossing required:%s\n",            YESNO(p->ara46));
			fprintf(fp, "RA:Sense reversal:%s\n",               YESNO(p->ara47));
		}


		pr_RAT(fp, p->RAT);
		pr_RAC(fp, p->RAC);
		pr_TTI(fp, p->TTI);

		if (p->TTI == 1) {
			fprintf(fp, "Threat identity data:%06X\n", p->TID);
		} else {
			pr_TIDR(fp, p->TIDR);
			pr_TIDB(fp, p->TIDB);
			pr_AC(fp, &p->TIDA);
		}
	}

}

void
pr_BDS_30(FILE *fp, const struct ms_BDS_30_t *p, int v) {
	if (v == 1) {
		pr_raw(fp, 0, 0, 0, "TODO");
	} else {
		fprintf(fp, "BDS:3,0:ACAS active resolution advisory\n");
		pr_ACAS_RA(fp, p,v );
	}
}
